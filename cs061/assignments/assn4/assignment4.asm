;=========================================================================
; Name & Email must be EXACTLY as in Gradescope roster!
; Name: Gabrielle John
; Email: gjohn010@ucr.edu
; 
; Assignment name: Assignment 4
; Lab section: 025
; TA: Robert Colvin
; 
; I hereby certify that I have not received assistance on this assignment,
; or used code, from ANY outside source other than the instruction team
; (apart from what was provided in the starter file).
;
;=================================================================================
;THE BINARY REPRESENTATION OF THE USER-ENTERED DECIMAL NUMBER MUST BE STORED IN R5
;=================================================================================

					.ORIG x3000		
					JSR MAIN_START
;-------------
;Instructions
;-------------

; output intro prompt
MAIN_START
	LD R0, introPromptPtr
	PUTS		
; Set up flags, counters, accumulators as needed
	AND R1,R1,#0 ;REGISTER TO STORE CHAR
	AND R2,R2,#0 ;REGISTER TO STORE FLAG
	AND R3,R3,#0 ;COUNTER
	AND R4,R4,#0 ;TEMPORARY REGISTER
	AND R5,R5,#0 ;REGISTER TO STORE FINAL RESULT
	AND R6,R6,#0 ;REGISTER TO LOAD LABELS TO AVOID OVERFLOW
	AND R7,R7,#0 ;STORE INITIAL VALUE OF R4 TEMPORARILY
; Get first character, test for '\n', '+', '-', digit/non-digit
LOOP
	GETC ;CHAR IS STORED IN R0
	OUT
	ADD R1,R0,#0 ;LOAD FIRST CHAR INTO R1
	LD R6,ENTER
	ADD R1,R1,R6 ;CHECK IF USER ENTERED A NEWLINE MANUALLY
	BRz NEWLINE_LOOP ;IF SO, GO TO ENDING LOOP
	BRnp CHECK_SIGN_LOOP ;IF NOT, CHECK SIGNS
	
	
; is very first character = '\n'? if so, just quit (no message)!
;ENDING_LOOP
	;LD R0,NEWLINE
	;OUT
	;BR NEWLINE_LOOP
	;STOP

; is it = '+'? if so, ignore it, go get digits
CHECK_SIGN_LOOP
	ADD R1,R0,#0	   ;AGAIN, LOAD R0 TO R1
	LD R6,POS_SIGN     ;LOAD R6 WITH ASCII VALUE OF '+' SIGN
	ADD R1,R1,R6 	   ;CHECK IF CHAR INPUTTED WAS '+'
	BRz IGNORE_SIGN_LOOP ;IF SO, IGNORE AND GO STRAIGHT TO GETTING DIGITS
	BRnp CHECK_FOR_NEG_LOOP ;CHECK FOR NEG SIGN SINCE ASCII OF '-' IS GREATER THAN THE POSITIVE VALUE OF '+'
	
IGNORE_SIGN_LOOP
	GETC
	OUT
	ADD R1,R0,#0
	;LD R3,COUNTER
	LD R6,ENTER
	ADD R1,R1,R6
	BRz NEWLINE_LOOP
	;ADD R3,R3,#-1
	BR LESS_THAN_ZERO_FOR_PLUS_SIGN

LESS_THAN_ZERO_FOR_PLUS_SIGN
	ADD R1,R0,#0
	LD R6,ZERO
	ADD R1,R1,R6 ;ADD NEG ASCII VAL OF 0 TO CHECK IF ITS LESS THAN 0
	BRn OUTPUT_ERROR_MSG_LESS_THAN_ZERO2 
	BR  GREATER_THAN_NINE_FOR_PLUS_SIGN ;IF IT IS POSITIVE THEN CHECK IF VAL IS GREATER THAN 9
OUTPUT_ERROR_MSG_LESS_THAN_ZERO2
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START WHOLE PROCESS OVER
	
GREATER_THAN_NINE_FOR_PLUS_SIGN
	ADD R1,R0,#0
	LD R6,NINE
	ADD R1,R1,R6 ;SUBTRACT ASCII VALUE OF 9 TO R1
	BRp OUTPUT_ERROR_MSG_GREATER_THAN_NINE2 ;IF POSITIVE (>9) THEN OUTPUT ERROR MESSAGE
	BR  ADD_FIRST_CHAR_WHEN_PLUS_SIGN_ENTERED ;THIS MEANS THAT IT IS WITHIN RANGE AND WE CAN GO GET REMAINING DIGITS
OUTPUT_ERROR_MSG_GREATER_THAN_NINE2
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START OVER
	
ADD_FIRST_CHAR_WHEN_PLUS_SIGN_ENTERED
	ADD R4,R0,#0 ;LOAD FIRST CHAR INTO R4
	LD R3,COUNTER ;LOAD COUNTER INTO R3
	LD R6,ASCII_TO_DEC
	ADD R4,R4,R6 ;CONVERT ASCII TO DECIMAL
	ADD R5,R4,#0 ;ADD (LOAD) VALUE INTO DESIGNATED REGISTER

	ADD R3,R3,#-1 ;DECREMENT COUNTER
	BR GET_REMAINING_DIGITS
; is it = '-'? if so, set neg flag, go get digits
CHECK_FOR_NEG_LOOP
	ADD R1,R0,#0
	LD R6,NEG_SIGN
	ADD R1,R1,R6
	BRz SET_FLAG ;IF THERE IS A NEGATIVE SIGN, SET FLAG TO -1
	BR LESS_THAN_ZERO_LOOP ;IF NOT, CHECK IF CHAR LESS THAN 0			 
SET_FLAG
	ADD R2,R2,#-1
	BR GET_FIRST_CHAR_FOR_NEG_NUM ;GO IMMEDIATELY TO GETTING THE FIRST CHAR FOR NEG NUM
GET_FIRST_CHAR_FOR_NEG_NUM
	GETC
	OUT
	ADD R1,R0,#0
	LD R6,ENTER
	ADD R1,R1,R6
	BRz CHECK_IF_NEG_SIGN_WAS_ENTERED
	BR LESS_THAN_ZERO_LOOP_FOR_NEG_SIGN
LESS_THAN_ZERO_LOOP_FOR_NEG_SIGN
	ADD R1,R0,#0
	LD R6,ZERO
	ADD R1,R1,R6 ;ADD NEG ASCII VAL OF 0 TO CHECK IF ITS LESS THAN 0
	BRn OUTPUT_ERROR_MSG_LESS_THAN_ZERO_FOR_NEG_SIGN 
	BR  GREATER_THAN_NINE_LOOP_FOR_NEG_SIGN ;IF IT IS POSITIVE THEN CHECK IF VAL IS GREATER THAN 9
OUTPUT_ERROR_MSG_LESS_THAN_ZERO_FOR_NEG_SIGN 
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START WHOLE PROCESS OVER
GREATER_THAN_NINE_LOOP_FOR_NEG_SIGN
	ADD R1,R0,#0
	LD R6,NINE
	ADD R1,R1,R6 ;SUBTRACT ASCII VALUE OF 9 TO R1
	BRp OUTPUT_ERROR_MSG_GREATER_THAN_NINE_FOR_NEG_SIGN ;IF POSITIVE (>9) THEN OUTPUT ERROR MESSAGE
	BR  ADD_FIRST_CHAR_WHEN_NEG_SIGN_ENTERED ;THIS MEANS THAT IT IS WITHIN RANGE AND WE CAN GO TO FIRST CHAR
OUTPUT_ERROR_MSG_GREATER_THAN_NINE_FOR_NEG_SIGN
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START OVER
ADD_FIRST_CHAR_WHEN_NEG_SIGN_ENTERED
	ADD R4,R0,#0 ;LOAD FIRST CHAR INTO R4
	LD R3,COUNTER ;LOAD COUNTER INTO R3
	LD R6,ASCII_TO_DEC
	ADD R4,R4,R6 ;CONVERT ASCII TO DECIMAL
	ADD R5,R4,#0 ;ADD (LOAD) VALUE INTO DESIGNATED REGISTER

	ADD R3,R3,#-1 ;DECREMENT COUNTER
	BR GET_REMAINING_DIGITS
; is it < '0'? if so, it is not a digit	- o/p error message, start over
LESS_THAN_ZERO_LOOP
	ADD R1,R0,#0
	LD R6,ZERO
	ADD R1,R1,R6 ;ADD NEG ASCII VAL OF 0 TO CHECK IF ITS LESS THAN 0
	BRn OUTPUT_ERROR_MSG_LESS_THAN_ZERO 
	BR  GREATER_THAN_NINE_LOOP ;IF IT IS POSITIVE THEN CHECK IF VAL IS GREATER THAN 9
OUTPUT_ERROR_MSG_LESS_THAN_ZERO
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START WHOLE PROCESS OVER
	
; is it > '9'? if so, it is not a digit	- o/p error message, start over
GREATER_THAN_NINE_LOOP
	ADD R1,R0,#0
	LD R6,NINE
	ADD R1,R1,R6 ;SUBTRACT ASCII VALUE OF 9 TO R1
	BRp OUTPUT_ERROR_MSG_GREATER_THAN_NINE ;IF POSITIVE (>9) THEN OUTPUT ERROR MESSAGE
	BR  GET_FIRST_CHAR ;THIS MEANS THAT IT IS WITHIN RANGE AND WE CAN GO TO FIRST CHAR
OUTPUT_ERROR_MSG_GREATER_THAN_NINE
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START ;START OVER
	
; if none of the above, first character is first numeric digit - deal with it!
GET_FIRST_CHAR
	ADD R4,R0,#0 ;LOAD FIRST CHAR INTO R4
	LD R3,COUNTER ;LOAD COUNTER INTO R3
	LD R6,ASCII_TO_DEC
	ADD R4,R4,R6 ;CONVERT ASCII TO DECIMAL
	ADD R5,R4,#0 ;ADD (LOAD) VALUE INTO DESIGNATED REGISTER

	ADD R3,R3,#-1 ;DECREMENT COUNTER
	BR GET_REMAINING_DIGITS
	
; Now get (remaining) digits (max 5) from user and build up number in accumulator
GET_REMAINING_DIGITS
	GETC
	OUT
	ADD R1,R0,#0
	LD R6,ENTER
	ADD R1,R1,R6 ;CHECK FOR NEWLINE
	BRz CHECK_IF_NEG_SIGN_WAS_ENTERED ;CHECK IF THERE WAS A NEG SIGN ENTERED
	BR LESS_THAN_ZERO_LOOP2 ;ALWAYS CHECK IF IT IS A VALID CHAR

LESS_THAN_ZERO_LOOP2
	ADD R1,R0,#0
	LD R6,ZERO
	ADD R1,R1,R6 ;ADD NEG ASCII VAL OF 0 TO CHECK IF ITS LESS THAN 0
	BRn OUTPUT_ERROR_MSG_LESS_THAN_ZERO3 
	BR  GREATER_THAN_NINE_LOOP2 ;IF IT IS POSITIVE THEN CHECK IF VAL IS GREATER THAN 9
OUTPUT_ERROR_MSG_LESS_THAN_ZERO3
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START
	
GREATER_THAN_NINE_LOOP2
	ADD R1,R0,#0
	LD R6,NINE
	ADD R1,R1,R6
	BRp OUTPUT_ERROR_MSG_GREATER_THAN_NINE3
	BR  ADD_ADDITIONAL_DIGITS
OUTPUT_ERROR_MSG_GREATER_THAN_NINE3
	LD R0,NEWLINE
	OUT
	LD R0,errorMessagePtr
	PUTS
	BR MAIN_START

ADD_ADDITIONAL_DIGITS
	ADD R4,R5,#0 ;LOAD R5 INTO TEMPORARY REGISTER
	ADD R7,R4,#0
	
	ADD R7,R7,R4 ;"MULTIPLY" BY 10 (ADD 10 TO THE REGISTER 9 TIMES)
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	ADD R7,R7,R4
	;ADD R7,R7,R4
	
	LD R6,ASCII_TO_DEC
	ADD R0,R0,R6 ;CONVERT NEWLY INPUTTED VALUE TO DECIMAL
	
	ADD R7,R7,R0 ;ADD NUMBER STORED IN R0 TO THE NUMBER THAT WAS JUST MULTIPLIED BY 10
	
	ADD R5,R7,#0 ;LOAD VALUE INTO R5
	
	ADD R3,R3,#-1 ;DECREMENT COUNTER
	BRp GET_REMAINING_DIGITS ;IF NOT THE END, THEN REPEAT PROCESS
	
	ADD R2,R2,#0 ;WHEN ZERO, IT WILL CHECK THE FLAG STORED IN R2
	BRn TWOS_COMP ;IF NEG, DO TWOS COMP
	BRzp NEWLINE_LOOP ;IF ZERO OR POSITIVE THEN GO TO NEWLINE_LOOP
	
TWOS_COMP
	NOT R5,R5
	ADD R5,R5,#1
	BR NEWLINE_LOOP
	
CHECK_IF_NEG_SIGN_WAS_ENTERED
	ADD R2,R2,#0
	BRn TWOS_COMP
	BRzp NEWLINE_LOOP
; remember to end with a newline!
NEWLINE_LOOP
	LD R0,NEWLINE
	OUT		
	HALT

;---------------	
; Program Data
;---------------

introPromptPtr		.FILL x3A00
errorMessagePtr		.FILL x3B00
NEWLINE				.FILL '\n'
ENTER 				.FILL  #-10
POS_SIGN			.FILL  #-43
NEG_SIGN 			.FILL  #-45
ZERO				.FILL  #-48
NINE				.FILL  #-57
ASCII_TO_DEC		.FILL  #-48
COUNTER 			.FILL  #5

;------------
; Remote data
;------------
					.ORIG x3A00			; intro prompt
					.STRINGZ	"Input a positive or negative decimal number (max 5 digits), followed by ENTER\n"
					
					
					.ORIG x3B00			; error message
					.STRINGZ	"ERROR: invalid input\n"

;---------------
; END of PROGRAM
;---------------
					.END

;-------------------
; PURPOSE of PROGRAM
;-------------------
; Convert a sequence of up to 5 user-entered ascii numeric digits into a 16-bit two's complement binary representation of the number.
; if the input sequence is less than 5 digits, it will be user-terminated with a newline (ENTER).
; Otherwise, the program will emit its own newline after 5 input digits.
; The program must also output a final newline.
; Input validation is performed on the individual characters as they are input, but not on the magnitude of the number.
